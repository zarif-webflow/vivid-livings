{
  "version": 3,
  "sources": ["../src/features/places-api.ts"],
  "sourcesContent": ["import { Loader } from \"@googlemaps/js-api-loader\";\r\nimport { getActiveScript, getHtmlElement } from \"@taj-wf/utils\";\r\nimport { debounce } from \"es-toolkit\";\r\n\r\nconst scriptElement = getActiveScript(import.meta.url);\r\n\r\nif (!scriptElement) {\r\n  throw new Error(\"Search Address script element was not found!\");\r\n}\r\n\r\nconst placesApiKey = scriptElement.getAttribute(\"data-places-key\");\r\n\r\nif (!placesApiKey) {\r\n  throw new Error(\r\n    \"Places API key was not found in the script element! Please set data-places-key attribute in the script.\"\r\n  );\r\n}\r\n\r\nconst loader = new Loader({\r\n  apiKey: placesApiKey,\r\n  version: \"weekly\",\r\n});\r\n\r\nconst processLocationString = (location: string) => {\r\n  return location.replaceAll(\" - \", \", \").replaceAll(\" | \", \", \");\r\n};\r\n\r\nconst getAutocompleteSuggestionsFunc = async () => {\r\n  const { AutocompleteSuggestion } = await loader.importLibrary(\"places\");\r\n\r\n  const addressQueryCache: Map<string, string[]> = new Map();\r\n\r\n  const fetchAddresses = async (query: string, callback: (result: string[]) => void) => {\r\n    const cachedResult = addressQueryCache.get(query);\r\n    if (cachedResult !== undefined) {\r\n      callback(cachedResult);\r\n      return;\r\n    }\r\n\r\n    try {\r\n      const request: google.maps.places.AutocompleteRequest = {\r\n        input: query,\r\n        includedRegionCodes: [\"ae\"],\r\n        includedPrimaryTypes: [\r\n          \"lodging\",\r\n          \"sublocality\",\r\n          \"apartment_complex\",\r\n          \"neighborhood\",\r\n          // \"establishment\",\r\n          \"condominium_complex\",\r\n        ],\r\n      };\r\n\r\n      const suggestions = await AutocompleteSuggestion.fetchAutocompleteSuggestions(request);\r\n\r\n      console.clear();\r\n\r\n      suggestions.suggestions.forEach((suggestion) => {\r\n        const mainLocationResult = suggestion?.placePrediction.mainText?.text;\r\n\r\n        if (!mainLocationResult) {\r\n          throw new Error(\"No main text found for suggestion\");\r\n          return;\r\n        }\r\n\r\n        const processedLocation = processLocationString(mainLocationResult);\r\n\r\n        console.log(\"-------\");\r\n        // console.log(\"-----------\");\r\n        // console.log(\"--------------\");\r\n        console.log(processedLocation);\r\n        console.log(suggestion?.placePrediction?.types);\r\n        console.log(\"--------------\");\r\n        // console.log(\"-----------\");\r\n        // console.log(\"-------\");\r\n      });\r\n\r\n      // console.log(JSON.stringify(suggestions.suggestions.at(0)?.placePrediction, null, 2));\r\n\r\n      const result = suggestions.suggestions\r\n        .filter((suggestion) => suggestion.placePrediction != null)\r\n        .map((suggestion) => suggestion.placePrediction!.text.text);\r\n\r\n      addressQueryCache.set(query, result);\r\n      callback(result);\r\n    } catch (error) {\r\n      console.error(\"Something went wrong with places api:\", error);\r\n      // Return empty array on error and cache it to avoid repeated failed requests\r\n      const emptyResult: string[] = [];\r\n      addressQueryCache.set(query, emptyResult);\r\n      callback(emptyResult);\r\n    }\r\n  };\r\n\r\n  const debouncedFetchAddresses = debounce(fetchAddresses, 100);\r\n\r\n  return { fetchAddresses: debouncedFetchAddresses };\r\n};\r\n\r\nexport const fetchAddresses = getAutocompleteSuggestionsFunc();\r\n\r\nconst init = async () => {\r\n  fetchAddresses.then(({ fetchAddresses }) => {\r\n    console.log(\"Autocompletetions Loaded Succesfully!\");\r\n\r\n    const inputEl = getHtmlElement({ selector: \"[data-search-input]\" });\r\n\r\n    if (!inputEl) return;\r\n\r\n    inputEl.addEventListener(\"input\", () => {\r\n      const value = (inputEl as HTMLInputElement).value;\r\n\r\n      fetchAddresses(value, (results) => {\r\n        // console.log(\"Autocomplete results:\", results);\r\n      });\r\n    });\r\n  });\r\n};\r\n\r\ninit();\r\n"],
  "mappings": ";;;;;;;;;;;;;;;AAAA;AAIA,IAAM,gBAAgB,gBAAgB,YAAY,GAAG;AAErD,IAAI,CAAC,eAAe;AAClB,QAAM,IAAI,MAAM,8CAA8C;AAChE;AAEA,IAAM,eAAe,cAAc,aAAa,iBAAiB;AAEjE,IAAI,CAAC,cAAc;AACjB,QAAM,IAAI;AAAA,IACR;AAAA,EACF;AACF;AAEA,IAAM,SAAS,IAAI,OAAO;AAAA,EACxB,QAAQ;AAAA,EACR,SAAS;AACX,CAAC;AAED,IAAM,wBAAwB,CAAC,aAAqB;AAClD,SAAO,SAAS,WAAW,OAAO,IAAI,EAAE,WAAW,OAAO,IAAI;AAChE;AAEA,IAAM,iCAAiC,YAAY;AACjD,QAAM,EAAE,uBAAuB,IAAI,MAAM,OAAO,cAAc,QAAQ;AAEtE,QAAM,oBAA2C,oBAAI,IAAI;AAEzD,QAAMA,kBAAiB,OAAO,OAAe,aAAyC;AACpF,UAAM,eAAe,kBAAkB,IAAI,KAAK;AAChD,QAAI,iBAAiB,QAAW;AAC9B,eAAS,YAAY;AACrB;AAAA,IACF;AAEA,QAAI;AACF,YAAM,UAAkD;AAAA,QACtD,OAAO;AAAA,QACP,qBAAqB,CAAC,IAAI;AAAA,QAC1B,sBAAsB;AAAA,UACpB;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA;AAAA,UAEA;AAAA,QACF;AAAA,MACF;AAEA,YAAM,cAAc,MAAM,uBAAuB,6BAA6B,OAAO;AAErF,cAAQ,MAAM;AAEd,kBAAY,YAAY,QAAQ,CAAC,eAAe;AAC9C,cAAM,qBAAqB,YAAY,gBAAgB,UAAU;AAEjE,YAAI,CAAC,oBAAoB;AACvB,gBAAM,IAAI,MAAM,mCAAmC;AACnD;AAAA,QACF;AAEA,cAAM,oBAAoB,sBAAsB,kBAAkB;AAElE,gBAAQ,IAAI,SAAS;AAGrB,gBAAQ,IAAI,iBAAiB;AAC7B,gBAAQ,IAAI,YAAY,iBAAiB,KAAK;AAC9C,gBAAQ,IAAI,gBAAgB;AAAA,MAG9B,CAAC;AAID,YAAM,SAAS,YAAY,YACxB,OAAO,CAAC,eAAe,WAAW,mBAAmB,IAAI,EACzD,IAAI,CAAC,eAAe,WAAW,gBAAiB,KAAK,IAAI;AAE5D,wBAAkB,IAAI,OAAO,MAAM;AACnC,eAAS,MAAM;AAAA,IACjB,SAAS,OAAO;AACd,cAAQ,MAAM,yCAAyC,KAAK;AAE5D,YAAM,cAAwB,CAAC;AAC/B,wBAAkB,IAAI,OAAO,WAAW;AACxC,eAAS,WAAW;AAAA,IACtB;AAAA,EACF;AAEA,QAAM,0BAA0B,SAASA,iBAAgB,GAAG;AAE5D,SAAO,EAAE,gBAAgB,wBAAwB;AACnD;AAEO,IAAM,iBAAiB,+BAA+B;AAE7D,IAAM,OAAO,YAAY;AACvB,iBAAe,KAAK,CAAC,EAAE,gBAAAA,gBAAe,MAAM;AAC1C,YAAQ,IAAI,uCAAuC;AAEnD,UAAM,UAAU,eAAe,EAAE,UAAU,sBAAsB,CAAC;AAElE,QAAI,CAAC,QAAS;AAEd,YAAQ,iBAAiB,SAAS,MAAM;AACtC,YAAM,QAAS,QAA6B;AAE5C,MAAAA,gBAAe,OAAO,CAAC,YAAY;AAAA,MAEnC,CAAC;AAAA,IACH,CAAC;AAAA,EACH,CAAC;AACH;AAEA,KAAK;",
  "names": ["fetchAddresses"]
}
